---
layout: post
icon: file-text
title:  "Suggested Languages"
date:   2021-10-28 12:00:00 -0600
category: Types and Programming Languages
permalink: /types-and-programming-languages/suggested-languages
---

* TOC
{:toc}

## Introduction

It is not uncommon for me to be approached by aspiring or bored programmers for suggestions on
new programming languages to learn. Given that my formal and informal background is in
Type Systems and Programming Languages this is not surprising to me. What does surprise me is
that these requests come more often then they used to. I have a feeling that this is because
the industry is starting to finally come to the realization that something is wrong. *"Things
are too complicated, there must be a better way!"*. Asking about new languages and not just
the next incremental framework is a good sign.

Self taught programmers and hackers are very good in the limited domain they operate but
without a knowledge of history, or any formal foundation, they walk down dark alleys that
have already been mapped by those that came before us. How often do you see a programmer
with a junior or sadly, senior or  even "principal" title try to "parse" html with a
regular expression? How many of them would react with deep suspicion when exposed to a
simple state machine vs a 1,000+ line maze of switches and if/else statements? With such
a state of affairs, it's no wonder that even __if__ they ask about a "new" programming
language to learn what they really mean is that they want is "news"; something incrementally
different and familiar not fundamentally different. So a C# developer brags about learning
Java and maybe a smattering of JavaScript, or the Python programmer adds Perl and Ruby to
their resume. These aren't particularly different from one another. Being in the same
language family they are basically the same with slightly different clothing.

So when I am approached about new languages I often respond: *"Learn more about
the current language you use today. Once you reach the limits of that or come across
a hard problem, then ask me again."*. Then they either moves on to never ask
again, or they mention some close cousin to which I shrug and say: "Sure, why not".
But rarely (1 in 100 maybe) I do meet a programmer who did their homework and knows
how to ask a relatively deep question: *"What's the difference between a Functor and
an IMappable?"*, *"Can we write an entire application with 'if' statements or 'switch'
statements?"*. These are the types of questions and follow-on conversations that
lead to new programming languages and an appreciation for what is there.

Adopting a properly "new" programming language is not like picking up another
library or framework to make your job easier, it's adopting a new mindset, a
new philosophy, a different state of being.

> A language that doesn't affect the way you think about programming, is not worth knowing.
> <cite markdown="1">
[Alan Perlis](https://en.wikipedia.org/wiki/Alan_Perlis)
</cite>

If you count yourself among one of those programmers looking to escape the yoke[1] of the
language you are forced to use in your day-to-day job then I think this blog post is for you.
If you consider yourself seasoned, you might also find one or two things interesting here, otherwise
consider it a quick review and pass it over. You may complain: "I don't see language X mentioned".
The goal here is to introduce what I see as the best representatives of the particular paradigm.
Many languages support multiple paradigms (to differing degrees of success) but can muddy
the waters when one is wanting to immerse themselves. When you don't have an escape hatch into
familiar territory the path of least resistance is to learn the appropriate lessons the language
has to teach.

## Imperative and Procedural

Procedural programming is something you are likely most familiar with. It's basically

## Functional

## Function-Level

## Concatenative

## Object Orientation

## Logic

## Programs and Proofs

## Profound Jokes and the Esoteric

<https://en.wikipedia.org/wiki/FRACTRAN>

## Going Beyond

* Microsoft Excel
* Lacing as Computing

## Summary

## Further Reading

[1] The yoke around an oxen's neck feels no guilt. I suspect that programming language right now feels just as heavy.
