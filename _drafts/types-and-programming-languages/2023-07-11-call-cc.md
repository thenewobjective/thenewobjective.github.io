---
layout: post
icon: file-text
title:  "call/cc"
date:   2023-07-11 12:00:00 -0600
category: Types and Programming Languages
permalink: /types-and-programming-languages/call-cc
---

* TOC
{:toc}

## Introduction

<!--
In this article I will describe the call/cc function and how it can be used to
implement a variety of control flow mechanisms in TypeScript. I will also
compare the call/cc function to other control flow mechanisms such as
exceptions, generators, and green threads.
 -->

## Continuations

## Call with Current Continuation

### Scheme

### Standard ML

### TypeScript

<!-- The relationship with exceptions and why it's an escape hatch -->

/*
The main difference between the Python and TypeScript code is the way
 that errors are handled. In Python, the RuntimeWarning exception is used
 to signal that the continuation has been escaped. In TypeScript, a new Error
  object is created to represent the continuation. This is because TypeScript
   does not have a built-in RuntimeWarning exception.

The rest of the code is essentially the same in both languages. The callcc()
 function takes a function proc as input and returns the result of calling proc()
  with a special function throw() that can be used to escape the continuation.
 */

```ts
/**
 * Thrown to escape the current continuation.
 */
class ContError<T> extends Error {
  /**
   * The value to return from the continuation.
   */
  returnValue: any
}

/**
 * Calls the given function with a special function that can be used to escape
 * the current continuation.
 * @param proc The function to call with the escape function.
 * @returns The return value of proc.
 */
function callcc<T>(proc: (escape: any) => void) {
  const cErr = new ContError<T>("Unable to continue current continuation.");
  function escape(returnValue: T) {
    cErr.returnValue = returnValue;
    throw cErr;
  }
  try {
    return proc(escape);
  } catch (e) {
    if (e === cErr)
      return cErr.returnValue;
    else
      throw e;
  }
}

console.log(
  callcc(fail => 5 + 10 * callcc(escape => 100 * escape(3))) // 35
)

console.log(
  callcc(fail => 5 + 10 * callcc(escape => 100 * fail(3))) // 3
)
```

## Amb

## Generators

## Green Threads

## Fibers

## Conclusion

 <!-- npm library -->

## References and Further Reading

- https://stackoverflow.com/questions/612761/what-is-call-cc
- http://www.madore.org/~david/computers/callcc.html
- https://norvig.com/lispy2.html
- https://stackoverflow.com/questions/66962102/understanding-implementation-of-call-with-continuation
- https://matt.might.net/articles/programming-with-continuations--exceptions-backtracking-search-threads-generators-coroutines/
- <http://okmij.org/ftp/continuations/against-callcc.html>
- https://en.wikipedia.org/wiki/Call-with-current-continuation
- https://esdiscuss.org/topic/generators-vs-foreach
- Generators and CoRoutines https://2ality.com/2015/03/es6-generators.html
- https://wiki.haskell.org/Continuation
